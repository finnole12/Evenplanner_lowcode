/**
 * Code is auto-generated by Application Logic, DO NOT EDIT.
 * @version(2.0)
 */
const LCAPApplicationService = require('@sap/low-code-event-handler');
const crypto = require('crypto');
const before_Events_Create = require('./code/before-events-create');
const before_Users_Create_Update = require('./code/before-users-create-update');
const after_Surveys_Read = require('./code/after-surveys-read');
const before_Questions_Create_Update = require('./code/before-questions-create-update');
const before_Answers_Create = require('./code/before-answers-create');
const on_Processpayment_Processpayment = require('./code/on-processpayment-processpayment');
const on_Sendmessage_Sendmessage = require('./code/on-sendmessage-sendmessage');

class low_code_attempt_6Srv extends LCAPApplicationService {
    async init() {

        this.before('CREATE', 'Events', async (request) => {
            await before_Events_Create(request);
        });

        this.before(['CREATE', 'UPDATE'], 'Users', async (request) => {
            await before_Users_Create_Update(request);
        });

        this.after('READ', 'Surveys', async (results, request) => {
            await after_Surveys_Read(results, request);
        });

        this.before(['CREATE', 'UPDATE'], 'Questions', async (request) => {
            await before_Questions_Create_Update(request);
        });

        this.before('CREATE', 'Answers', async (request) => {
            await before_Answers_Create(request);
        });

        this.on('processPayment', async (request) => {
            return on_Processpayment_Processpayment(request);
        });

        this.on('sendMessage', async (request) => {
            return on_Sendmessage_Sendmessage(request, next);
        });

        this.on('getCurrentUserId', async (request) => {
            return { id: request.user.id };
        });

        this.on('addMessage', async (request) => {
            const { eventId, messageText } = request.data;
            if (!eventId || !messageText) {
                return { success: false };
            }

            const { EventMessages } = cds.entities;
            const newId = crypto.randomUUID();
            await INSERT.into(EventMessages).columns('ID', 'text', 'event_ID').values(newId, messageText, eventId);

            return { success: true };
        });

        this.on('makePayment', async (request) => {
            const { eventId } = request.data;
            const userId = request.user.id;

            if (!eventId || !userId) {
                return { success: false };
            }

            const { EventParticipants } = cds.entities;
            const participant = await SELECT.one.from(EventParticipants).where({ event_ID: eventId, user_ID: userId });

            if (!participant) {
                return { success: false };
            }

            participant.hasPayed = true;
            await cds.update(EventParticipants).set({ hasPayed: true }).where({ ID: participant.ID });

            return { success: true };
        });

        this.on('submitAnswers', async (request) => {
            const { surveyId, answers } = request.data;
            const userId = request.user.id;

            if (!surveyId || !answers || !userId) {
                return { success: false };
            }

            const { Surveys, Answers, UserAnswers } = cds.entities;
            const survey = await SELECT.one.from(Surveys).where({ ID: surveyId });

            if (!survey || !survey.isActive) {
                return { success: false };
            }

            // Delete existing UserAnswers entries for this user and survey
            const existingAnswers = await SELECT.from(UserAnswers).where({ user_ID: userId });
            const answerIdsToDelete = existingAnswers.map(answer => answer.answer_ID);

            await DELETE.from(UserAnswers).where({ user_ID: userId, answer_ID: { in: answerIdsToDelete } });

            for (const answerId of answers) {
                const answer = await SELECT.one.from(Answers).where({ ID: answerId });

                if (!answer) {
                    return { success: false };
                }

                // Insert new UserAnswers entry
                await INSERT.into(UserAnswers).columns('user_ID', 'answer_ID').values(userId, answerId);
            }

            return { success: true };
        });        
        
        this.on('createEvent', async (request) => {
            const { title, description, price, currency, dueDate, isPublic, maxCapacity } = request.data;

            console.log(request.data)

            if (!title || !description || price < 0 || !currency || !dueDate ) {
                return { success: false };
            }

            const { Events } = cds.entities;
            const newEventId = crypto.randomUUID();

            await INSERT.into(Events).columns(
                'ID', 'title', 'description', 'price', 'Currency_code', 'dueDate', 'isPublic', 'maxCapacity', 'manager_ID'
            ).values(
                newEventId, title, description, price, currency, dueDate, isPublic, maxCapacity, request.user.id
            );

            return { success: true };
        });        
        
        this.on('createSurvey', async (request) => {
            const { title, description, dueDate, isActive, eventId, anonymous, questions } = request.data;

            console.log(request.data)

            if (!title || !description || !dueDate || !eventId || !questions) {
                return { success: false };
            }

            const { Surveys, Questions, Answers } = cds.entities;
            const newSurveyId = crypto.randomUUID();

            await INSERT.into(Surveys).columns(
                'ID', 'title', 'description', 'dueDate', 'isActive', 'event_ID', 'isAnonymous'
            ).values(
                newSurveyId, title, description, dueDate, isActive, eventId, anonymous
            );

            for (const questionData of questions) {
                const { text, isMultipleChoice, answers } = questionData;
                if (!text || !answers) {
                    return { success: false };
                }

                const newQuestionId = crypto.randomUUID();
                await INSERT.into(Questions).columns(
                    'ID', 'text', 'isMultipleChoice', 'surveys_ID'
                ).values(
                    newQuestionId, text, isMultipleChoice, newSurveyId
                );

                for (const answerData of answers) {
                    const { text: answerText } = answerData;
                    if (!answerText) {
                        return { success: false };
                    }

                    const newAnswerId = crypto.randomUUID();
                    await INSERT.into(Answers).columns(
                        'ID', 'text', 'question_ID'
                    ).values(
                        newAnswerId, answerText, newQuestionId
                    );
                }
            }

            return { success: true };
        });

        return super.init();
    }
}

module.exports = {
    low_code_attempt_6Srv
};